// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"github.com/krisch/crm-backend/internal/activities"
	"github.com/krisch/crm-backend/internal/agents"
	"github.com/krisch/crm-backend/internal/aggregates"
	"github.com/krisch/crm-backend/internal/cache"
	"github.com/krisch/crm-backend/internal/catalogs"
	"github.com/krisch/crm-backend/internal/comments"
	"github.com/krisch/crm-backend/internal/company"
	"github.com/krisch/crm-backend/internal/configs"
	"github.com/krisch/crm-backend/internal/dictionary"
	"github.com/krisch/crm-backend/internal/emails"
	"github.com/krisch/crm-backend/internal/federation"
	"github.com/krisch/crm-backend/internal/gates"
	"github.com/krisch/crm-backend/internal/health"
	"github.com/krisch/crm-backend/internal/helpers"
	"github.com/krisch/crm-backend/internal/jwt"
	"github.com/krisch/crm-backend/internal/logs"
	"github.com/krisch/crm-backend/internal/notifications"
	"github.com/krisch/crm-backend/internal/permissions"
	"github.com/krisch/crm-backend/internal/profile"
	"github.com/krisch/crm-backend/internal/reminders"
	"github.com/krisch/crm-backend/internal/s3"
	"github.com/krisch/crm-backend/internal/sms"
	"github.com/krisch/crm-backend/internal/task"
	"github.com/krisch/crm-backend/pkg/postgres"
	"github.com/krisch/crm-backend/pkg/redis"
)

// Injectors from wire.go:

func InitApp(name string, creds postgres.Creds, metrics bool, rc redis.Creds) (*App, error) {
	configsConfigs := configs.NewConfigsFromEnv()
	gdb, err := postgres.NewGDB(creds, metrics)
	if err != nil {
		return nil, err
	}
	rds, err := redis.New(rc)
	if err != nil {
		return nil, err
	}
	service := health.NewHealthService(gdb, rds)
	repository := notifications.NewRepository(rds)
	metricsCounters := helpers.NewMetricsCounters()
	dictionaryRepository := dictionary.NewRepository(gdb, rds, metricsCounters)
	conf := s3Conf(configsConfigs)
	s3Repository := s3.NewRepository(gdb)
	s3Service := s3.New(conf, s3Repository)
	dictionaryService := dictionary.New(dictionaryRepository, metricsCounters, s3Service)
	profileRepository := profile.NewRepository(gdb, rds, metricsCounters)
	profileService := profile.New(configsConfigs, profileRepository, s3Service, dictionaryService)
	cacheRepository := cache.NewRepository(rds)
	cacheService := cache.New(cacheRepository, configsConfigs)
	taskRepository := task.NewRepository(gdb, rds, metricsCounters, cacheService)
	activitiesRepository := activities.NewRepository(gdb)
	activitiesService := activities.New(activitiesRepository, dictionaryService)
	commentsRepository := comments.NewRepository(gdb, rds, metricsCounters, cacheService)
	confPrivate := s3PrivateConf(configsConfigs)
	servicePrivate := s3.NewPrivate(confPrivate, s3Repository, cacheService)
	commentsService := comments.New(commentsRepository, dictionaryService, servicePrivate, activitiesService)
	taskService := task.New(taskRepository, dictionaryService, activitiesService, profileService, commentsService, servicePrivate)
	remindersRepository := reminders.NewRepository(gdb)
	remindersService := reminders.New(remindersRepository, dictionaryService)
	federationRepository := federation.NewRepository(gdb, rds)
	catalogsRepository := catalogs.NewRepository(gdb, rds, metricsCounters)
	catalogsService := catalogs.New(catalogsRepository, dictionaryService)
	federationService := federation.NewUserService(federationRepository, dictionaryService, catalogsService)
	aggregatesService := aggregates.New(dictionaryService, profileService, taskService, commentsService, servicePrivate, remindersService, federationService)
	notificationsService := notifications.New(repository, aggregatesService, dictionaryService)
	iLogRepository := logs.NewLogRepository(gdb)
	iLogService := logs.NewLogService(iLogRepository)
	emailRepository := emails.NewRepository(gdb)
	iEmailsService, err := emails.NewFromCreds(configsConfigs, emailRepository)
	if err != nil {
		return nil, err
	}
	gatesRepository := gates.NewRepository(gdb, rds)
	gatesService := gates.New(gatesRepository, dictionaryService)
	companyRepository := company.NewRepository(gdb, rds, cacheService)
	companyService := company.New(companyRepository, dictionaryService)
	smsRepository := sms.NewRepository(gdb)
	smsService := sms.New(smsRepository)
	agentsRepository := agents.NewRepository(gdb)
	agentsService := agents.New(agentsRepository)
	permissionsRepository := permissions.NewRepository(gdb, rds)
	permissionsService := permissions.New(permissionsRepository)
	app := NewApp(name, configsConfigs, gdb, rds, service, notificationsService, iLogService, profileService, iEmailsService, federationService, taskService, commentsService, dictionaryService, s3Service, servicePrivate, gatesService, cacheService, metricsCounters, remindersService, catalogsService, aggregatesService, companyService, smsService, agentsService, permissionsService)
	return app, nil
}

// wire.go:

func s3Conf(conf *configs.Configs) s3.Conf {
	return s3.Conf{
		Endpoint:        conf.CDN_PUBLIC_ENDPOINT,
		AccessKeyID:     conf.CDN_PUBLIC_ACCESS_KEY_ID,
		SecretAccessKey: conf.CDN_PUBLIC_SECRET_ACCESS_KEY,
		BucketName:      conf.CDN_PUBLIC_BUCKET_NAME,
		Location:        conf.CDN_PUBLIC_REGION,
		UseSSL:          conf.CDN_PUBLIC_SSL,
		PublicURL:       conf.CDN_PUBLIC_URL,
	}
}

func s3PrivateConf(conf *configs.Configs) s3.ConfPrivate {
	return s3.ConfPrivate{
		Endpoint:        conf.CDN_PRIVATE_ENDPOINT,
		AccessKeyID:     conf.CDN_PRIVATE_ACCESS_KEY_ID,
		SecretAccessKey: conf.CDN_PRIVATE_SECRET_ACCESS_KEY,
		BucketName:      conf.CDN_PRIVATE_BUCKET_NAME,
		Location:        conf.CDN_PRIVATE_REGION,
		UseSSL:          conf.CDN_PRIVATE_SSL,
		PublicURL:       conf.CDN_PRIVATE_URL,
		BackendURL:      conf.URL_BACKEND,
	}
}

func Configs() *configs.Configs {
	return &configs.Configs{}
}

func NewApp(name string, conf *configs.Configs, gdb *postgres.GDB, rds *redis.RDS,
	healthService *health.Service,
	notificationsService *notifications.Service,
	logService logs.ILogService,
	profileService *profile.Service,
	emailService emails.IEmailsService,
	federationService *federation.Service,
	taskService *task.Service,
	commentService *comments.Service,
	dictionaryService *dictionary.Service,
	s3Service *s3.Service,
	s3PrivateService *s3.ServicePrivate,
	gateService *gates.Service,
	cacheService *cache.Service,
	metricsCounters *helpers.MetricsCounters,
	remindersService *reminders.Service,
	catalogService *catalogs.Service,
	agregateService *aggregates.Service,
	companyService *company.Service,
	smsService *sms.Service,
	agentsService *agents.Service,
	permissionsService *permissions.Service,
) *App {
	w := &App{
		Env:  conf.ENV,
		Name: name,

		Port:    conf.PORT,
		Options: *conf,

		MetricsCounters: metricsCounters,
	}

	w.HealthService = healthService
	w.NotificationsService = notificationsService
	w.LogService = logService
	w.EmailService = emailService

	jwtService := jwt.New(conf.SOLT)
	jwtService.SetRefreshTokenValidator(func(token string) (bool, error) {
		return true, nil
	})
	jwtService.SetInvalidateToken(func(token string) (bool, error) {
		return true, nil
	})

	w.JWT = jwtService

	w.DictionaryService = dictionaryService
	w.GateService = gateService
	w.S3Service = s3Service
	w.S3PrivateService = s3PrivateService
	w.ProfileService = profileService
	w.CacheService = cacheService
	w.FederationService = federationService
	w.TaskService = taskService
	w.CommentService = commentService
	w.RemindersService = remindersService
	w.CatalogService = catalogService
	w.AgregateService = agregateService
	w.CompanyService = companyService
	w.SMSService = smsService
	w.AgentsService = agentsService
	w.PermissionsService = permissionsService

	return w
}
